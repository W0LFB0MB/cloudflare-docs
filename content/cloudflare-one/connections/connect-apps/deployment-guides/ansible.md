---
pcx_content_type: how-to
title: Ansible
weight: 8
---

# Deploy Tunnels with Ansible and Terraform

Ansible is a software tool that enables at scale management of infrastructure. Ansible is agentless â€” all it needs to function is the ability to SSH to the target and Python installed on the target.

Ansible works alongside Terraform to streamline the Cloudflare Tunnel setup process. This guide provides an example Terraform configuration file that deploys a virtual machine in Google Cloud Project and creates a Cloudflare Tunnel in your Zero Trust account. After deploying these resources with Terraform, you can then use Ansible to install and configure the `cloudflared` tunnel connector on the GCP server.

## Prerequisites

If you have never worked with Terraform before, we recommend that you first review our [Terraform guide](/cloudflare-one/connections/connect-apps/deployment-guides/terraform/). To complete the steps in this guide, you will need:

- [A Google Cloud Project](https://cloud.google.com/resource-manager/docs/creating-managing-projects#creating_a_project)
- [A zone on Cloudflare](/fundamentals/get-started/setup/add-site/)
- [Terraform installed](https://learn.hashicorp.com/tutorials/terraform/install-cli)
- [GCP CLI installed and authenticated](https://cloud.google.com/sdk/docs/install)
- [A Cloudflare API token](/fundamentals/api/get-started/create-token/) with `Cloudflare Tunnel` and `DNS` permissions.

## 1. Install Ansible

Refer to the [Ansible installation instructions](https://docs.ansible.com/ansible/latest/installation_guide/index.html).

## 2. Create a configuration directory

1. Create a folder for your Terraform and Ansible configuration files:

    ```sh
    $ mkdir gcp-tunnel
    ```

2. Change into the directory:

    ```sh
    $ cd gcp-tunnel
    ```

## 3. Create Terraform configuration files

### Define input variables

{{<render file="_terraform_input_variables.md">}}

### Assign values to variables

{{<render file="_terraform_variable_values.md">}}

### Configure Terraform providers

{{<render file="_terraform_providers.md">}}

### Configure Cloudflare resources

Terraform is used to create the tunnel that will be running. It can also create the DNS record that the tunnel will route to.

```sh
# The random_id resource is used to generate a 35 character secret for the tunnel
resource "random_id" "tunnel_secret" {
  byte_length = 35
}

# A Named Tunnel resource called ansible_ssh_http
resource "cloudflare_argo_tunnel" "auto_tunnel" {
  account_id = var.cloudflare_account_id
  name       = "ansible_ssh"
  secret     = random_id.tunnel_secret.b64_std
}

# DNS settings to CNAME to tunnel target for SSH
resource "cloudflare_record" "ssh_app" {
  zone_id = var.cloudflare_zone_id
  name    = "ssh"
  value   = "${cloudflare_argo_tunnel.auto_tunnel.id}.cfargotunnel.com"
  type    = "CNAME"
  proxied = true
}
```

### Configure GCP resources
Terraform can deploy GCP VM instances. Instead of having to use a bash script for any internal configuration of the instance, Ansible is used to complete that. All Terraform needs to accomplish for Ansible to deploy is install Python3 on the instance. 
```sh
# OS the server will use
data "google_compute_image" "image" {
  family  = "ubuntu-minimal-2004-lts"
  project = "ubuntu-os-cloud"
}

resource "google_compute_instance" "origin" {
  name         = "ansible-inst"
  machine_type = var.machine_type
  zone         = var.zone
  tags         = []
  boot_disk {
    initialize_params {
      image = data.google_compute_image.image.self_link
    }
  }
  network_interface {
    network = "default"
    access_config {
      // Ephemeral IP
    }
  }
  scheduling {
    preemptible = true
    automatic_restart = false
  }
#Install Python3
  provisioner "remote-exec" {
    inline = [
      "sudo apt update", "sudo apt install python3 -y",  "echo Done!"
    ]
    connection {
      host = self.network_interface.0.access_config.0.nat_ip
      user = var.name
      type = "ssh"
      #If a SSH key is needed to connect use `private_key = file("<path to private key>)`
    }
  }
  provisioner "local-exec" {
    # If a SSH key and user need to be specified add `--private-key <path to private key> -u var.name`
    command = "ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook  -i ${self.network_interface.0.access_config.0.nat_ip}, main.yml"
  }
  metadata = {
      cf-terraform = "demo_tf_kitchensink"
      cf-email     = var.cloudflare_email
      cf-zone      = var.cloudflare_zone
  }
  depends_on = [
    local_file.tf_ansible_vars_file
  ]
}
```

### Export Tunnel variables to Ansible

The tunnel id and other requirements for running the tunnel will be exported to tf_ansible_vars_file.yml. Ansible will then use this file to access the ids and secrets needed.

```sh
resource "local_file" "tf_ansible_vars_file" {
  content = <<-DOC
    # Ansible vars_file containing variable values from Terraform.
    # Generated by Terraform mgmt configuration.
    tunnel_id: ${cloudflare_argo_tunnel.auto_tunnel.id}
    account: ${var.cloudflare_account_id}
    tunnel_name: ${cloudflare_argo_tunnel.auto_tunnel.name}
    secret: ${random_id.tunnel_secret.b64_std}
    zone: ${var.cloudflare_zone}
    DOC

  filename = "./tf_ansible_vars_file.yml"
}
```

## 4. Create the Ansible playbook

Ansible playbooks are YAML files that declare the configuration that Ansible will deploy. 
3. Create a `.yml` file:

    ```sh
    $ touch playbook.yml
    ```

4. Add the following content to your `playbook.yml` file:

  ```yml
    ---
    - hosts: all
      become: yes
    # Import tunnel variables into the VM
    vars_files:
      - ./tf_ansible_vars_file.yml
    # Execute the following commands on the VM
    tasks:
      - name: download cloudflared package
        shell: wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
      - name: depackage cloudflared
        shell: sudo dpkg -i cloudflared-linux-amd64.deb
      - name: Create cloudflared service directory 
        shell: mkdir -p /etc/cloudflared/
      - name: Creating the ingress rules and the config file for cloudflared
        copy:
          dest: "/etc/cloudflared/config.yml"
          content: |
            tunnel: "{{ tunnel_id }}"
            credentials-file: /etc/cloudflared/cert.json
            logfile: /var/log/cloudflared.log
            loglevel: info    
            ingress:
              - hostname: "ssh.{{ zone }}"
                service: ssh://localhost:22
              - service: http_status:404
      - name: Creating cred.json file for cloudflared
        copy:
          dest: "/etc/cloudflared/cert.json"
          content: |
            {
              "AccountTag"   : "{{ account | quote }}",
              "TunnelID"     : "{{ tunnel_id | quote }}",
              "TunnelName"   : "{{ tunnel_name | quote }}",
              "TunnelSecret" : "{{ secret | quote }}"
            }
      - name: Installing cloudflared as a service
        shell: cloudflared service install
      - name: Start cloudflared service
        systemd:
          name: cloudflared
          state: started
          enabled: true
          masked: no
  ```
  
  [Keywords](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play) define how Ansible will execute the configuration. In the example above, the `vars_files` keyword specifies where variable definitions are stored, and the `tasks` keyword specifies the actions Ansible will perform.

  [Modules](https://docs.ansible.com/ansible/2.9/user_guide/modules.html) specify what tasks to complete. In this example, the `copy` module creates a file and populates it with content.
 
## 5. Deploy the configuration
Once the configuration files are created, it can be deployed through Terraform. The Ansible deployment happens within the Terraform deployment when the `ansible-playbook` command is run. First, to initialize the working directory run the `terraform init` command. This will set up the directory so that your infrastructure can be deployed.

Before actually deploying your infrastructure, a preview of everything that will be created can be displayed using the `terraform plan` command. Then to deploy the infrastructure use the `terraform apply` command. It may take several minutes for the GCP instance and tunnel to come online. When you check your Cloudflare dashboard the new records, application, policy, and tunnel will be visible.

The `terraform destroy` command can be used to delete everything created through terraform if it needs to be rolled back. The `terraform apply` and `terraform destroy` commands prompt user input. To run without requiring user input add the `-auto-approve` flag to the command.